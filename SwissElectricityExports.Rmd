---
title: "Swiss electricty exports"
output: html_notebook
---
First of all let us import the data : 
```{r}
#import data
library(readxl)
library(feasts)
Electricityraw <- read_excel("Electricity export Switzerland-3.xlsx")
```
## 1 Data and Wrangling 
Here, we are going to do some basic modification of the raw data in order to be a bit more readable
```{r}
# Rename the columns
colnames(Electricityraw) <- c("Date", "Germany", "France", "Austria", "Liechtenstein", "Italy", "Total.Export")
# Remove the first 4 rows
Electricity <- Electricityraw[-c(1:4), ]
# Change Oktober for October
Electricity$Date <- gsub("Oktober", "October", Electricity$Date)
# Convert the date column to a date object
Electricity$Date <- as.Date(paste0("01 ", Electricity$Date), format = "%d %B %Y")
```

Our column are in a character form, we want to transfrom them in a numeric format since they represent continuous values. 
```{r}
# Convert the electricity export columns to numeric
Electricity$Germany <- as.numeric(Electricity$Germany)
Electricity$France <- as.numeric(Electricity$France)
Electricity$Austria <- as.numeric(Electricity$Austria)
Electricity$Liechtenstein <- as.numeric(Electricity$Liechtenstein)
Electricity$Italy <- as.numeric(Electricity$Italy)
Electricity$Total.Export <- as.numeric(Electricity$Total.Export)
```


Lets check if there are some missing values in our dataset 
```{r}
# Check if there are any missing values in the dataset
missing_values <- is.na(Electricity)

# Check if any columns contain missing values
missing_values_per_column <- colSums(missing_values)
print(missing_values_per_column)
```
So apparently, there are are no missing values in our data. 

```{r eval=FALSE, include=FALSE}
# Function to identify and treat outliers using the IQR method
treat_outliers_iqr <- function(data, k = 1.5) {
  Q1 <- quantile(data, 0.25)
  Q3 <- quantile(data, 0.75)
  IQR <- Q3 - Q1
  lower_bound <- Q1 - k * IQR
  upper_bound <- Q3 + k * IQR

  # Replace outliers with NA
  data[data < lower_bound | data > upper_bound] <- NA
  return(data)
}

# Apply the function to each country's time series
Electricity$Germany <- treat_outliers_iqr(Electricity$Germany)
Electricity$France <- treat_outliers_iqr(Electricity$France)
Electricity$Austria <- treat_outliers_iqr(Electricity$Austria)
Electricity$Liechtenstein <- treat_outliers_iqr(Electricity$Liechtenstein)
Electricity$Italy <- treat_outliers_iqr(Electricity$Italy)
Electricity$Total.Export <- treat_outliers_iqr(Electricity$Total.Export)


```

## 2.0 Vizualisation 

### 2.1 Time series 
```{r}
# Create a time series object for the Total.Export data
ts_data <- ts(Electricity$Total.Export, start = c(2000, 1), frequency = 12)
# Create a time series object for the Germany data
ts_germany <- ts(Electricity$Germany, start = c(2000, 1), frequency = 12)
# Create a time series object for the France data
ts_france <- ts(Electricity$France, start = c(2000, 1), frequency = 12)
# Create a time series object for the Italy data
ts_italy <- ts(Electricity$Italy, start = c(2000, 1), frequency = 12)
# Create a time series object for the Austria data
ts_austria <- ts(Electricity$Austria, start = c(2000, 1), frequency = 12)
# Create a time series object for the Liechtenstein data
ts_liechtenstein <- ts(Electricity$Liechtenstein, start = c(2000, 1), frequency = 12)
# Plot the Total.Export time series
plot(ts_data, xlab = "Year", ylab = "Electricity export (GWh)", main = "Electricity Export - Total")
# Plot the Germany time series
plot(ts_germany, xlab = "Year", ylab = "Electricity export (GWh)", main = "Electricity Export - Germany")
# Plot the France time series
plot(ts_france, xlab = "Year", ylab = "Electricity export (GWh)", main = "Electricity Export - France")
# Plot the Italy time series
plot(ts_italy, xlab = "Year", ylab = "Electricity export (GWh)", main = "Electricity Export - Italy")
# Plot the Austria time series
plot(ts_austria, xlab = "Year", ylab = "Electricity export (GWh)", main = "Electricity Export - Austria")
# Plot the Liechtenstein time series
plot(ts_liechtenstein, xlab = "Year", ylab = "Electricity export (GWh)", main = "Electricity Export - Liechtenstein")
```
At first glance, we can guess that there is seasonality for each country. If we focus ourselves on stationary of the data, we can easily say that Italie and Lichtnestein are stationary. There is a huge drop in 2009 for the electricity export in Italie. For the Lichtenstein, we observe a a low increase from 2017 to 2020 followed by a small drop. 



### 2.1 STL Decomposition 
```{r}
# Define the countries vector
countries <- c("Germany", "France", "Austria", "Liechtenstein", "Italy", "Total.Export")

# Function to create and plot seasonal decomposition for a given country
plot_stl_decomposition <- function(data, country) {
  # Create a time series object
  country_ts <- ts(data[[country]], start = c(2000, 1), frequency = 12)
  
  # Perform STL decomposition
  country_stl <- stl(country_ts, s.window = "periodic")
  
  # Plot the seasonal decomposition
  plot(country_stl, main = paste("STL Decomposition for", country))
}

# Use the function to create and display STL decomposition plots for each country
for (country in countries) {
  plot_stl_decomposition(Electricity, country)
}

```
Italie : Clear seasonality with raises in Winter and drops in Summer. As for the trend, from 2000 to 2008, we observe a small incrase followed by huge drop until 2010. Since 2010, the trend is constant. 

Lichtenstein : Clear sesonality with drops every beggning of the years while raising for the Summer. The trend shows constant value until 2017 where there is a huge raise until 2020. This raise is followed by a drop until 2021 and then a small increase.

```{r}
# Function to create and display the seasonal subseries plot for a given country
plot_seasonal_subseries <- function(data, country) {
  # Create a time series object
  country_ts <- ts(data[[country]], start = c(2000, 1), frequency = 12)
  
  # Create a seasonal subseries plot
  seasonal_subseries_plot <- ggseasonplot(country_ts, year.labels = TRUE, year.labels.left = TRUE,
                                          main = paste("Seasonal Subseries Plot for", country),
                                          xlab = "Month", ylab = "Electricity Export (GWh)")

  # Display the plot
  print(seasonal_subseries_plot)
}

# Use the function to create and display seasonal subseries plots for each country
for (country in countries) {
  plot_seasonal_subseries(Electricity, country)
}
```

```{r}
# Load necessary libraries
library(tsibble)
library(feasts)

# Convert the time series objects to tsibble objects
ts_data_tsibble <- ts_data %>% as_tsibble(index = index(ts_data))
ts_germany_tsibble <- ts_germany %>% as_tsibble(index = index(ts_germany))
ts_france_tsibble <- ts_france %>% as_tsibble(index = index(ts_france))
ts_italy_tsibble <- ts_italy %>% as_tsibble(index = index(ts_italy))
ts_austria_tsibble <- ts_austria %>% as_tsibble(index = index(ts_austria))
ts_liechtenstein_tsibble <- ts_liechtenstein %>% as_tsibble(index = index(ts_liechtenstein))

# Create seasonal subseries plots for each country using tsibble objects
germany_plot <- gg_subseries(ts_germany_tsibble) +
  ggtitle("Seasonal Subseries Plot for Germany") +
  xlab("Month") + ylab("Electricity Export (GWh)")

france_plot <- gg_subseries(ts_france_tsibble) +
  ggtitle("Seasonal Subseries Plot for France") +
  xlab("Month") + ylab("Electricity Export (GWh)")

austria_plot <- gg_subseries(ts_austria_tsibble) +
  ggtitle("Seasonal Subseries Plot for Austria") +
  xlab("Month") + ylab("Electricity Export (GWh)")

liechtenstein_plot <- gg_subseries(ts_liechtenstein_tsibble) +
  ggtitle("Seasonal Subseries Plot for Liechtenstein") +
  xlab("Month") + ylab("Electricity Export (GWh)")

italy_plot <- gg_subseries(ts_italy_tsibble) +
  ggtitle("Seasonal Subseries Plot for Italy") +
  xlab("Month") + ylab("Electricity Export (GWh)")

total_export_plot <- gg_subseries(ts_data_tsibble) +
  ggtitle("Seasonal Subseries Plot for Total.Export") +
  xlab("Month") + ylab("Electricity Export (GWh)")

# Display the plots
print(germany_plot)
print(france_plot)
print(austria_plot)
print(liechtenstein_plot)
print(italy_plot)
print(total_export_plot)

```
```{r}
# Load necessary library
library(ggplot2)

# Function to create ACF plot for a given time series
plot_acf <- function(ts_data, country) {
  acf_data <- acf(ts_data, plot = FALSE)
  acf_df <- data.frame(Lag = 1:length(acf_data$acf), ACF = acf_data$acf)
  ggplot(acf_df, aes(x = Lag, y = ACF)) + geom_bar(stat = "identity") +
    ggtitle(paste("ACF plot for", country)) +
    xlab("Lag") + ylab("Autocorrelation") +
    theme_minimal()
}

# Create and display ACF plots for each country
plot_acf(ts_data, "Total.Export")
plot_acf(ts_germany, "Germany")
plot_acf(ts_france, "France")
plot_acf(ts_italy, "Italy")
plot_acf(ts_austria, "Austria")
plot_acf(ts_liechtenstein, "Liechtenstein")


```
## 3.0 Cleaning and wrankling

## 4.0 Modeling 

### ETS model 
```{r}
fit_and_forecast_ets <- function(ts_data, country) {
  # Fit the ETS model with ZZZ (chooses automatically the best)
  ets_model <- ets(ts_data, "ZZZ")
  
  # Print the chosen model
  cat("Chosen ETS model for", country, ":", ets_model$components, "\n")
  
  # Generate a forecast
  ets_forecast <- forecast(ets_model, h = 12) # Forecast 12 months ahead
  
  # Plot the forecast
  plot(ets_forecast, main = paste("ETS Forecast for", country))
}

fit_and_forecast_ets(ts_germany, "Germany")
fit_and_forecast_ets(ts_france, "France")
fit_and_forecast_ets(ts_italy, "Italy")
fit_and_forecast_ets(ts_austria, "Austria")
fit_and_forecast_ets(ts_liechtenstein, "Liechtenstein")
fit_and_forecast_ets(ts_data, "Total.Export")

```

So here is what R chooses automatically for us : 

Germany: M A M (Multiplicative Error, Additive Trend, Multiplicative Seasonal, and Box-Cox transformation is used)
France: M N M (Multiplicative Error, No Trend, Multiplicative Seasonal, and no Box-Cox transformation)
Italy: A N A (Additive Error, No Trend, Additive Seasonal, and no Box-Cox transformation)
Austria: A N A (Additive Error, No Trend, Additive Seasonal, and no Box-Cox transformation)
Liechtenstein: A N A (Additive Error, No Trend, Additive Seasonal, and no Box-Cox transformation)
Total.Export: A N A (Additive Error, No Trend, Additive Seasonal, and no Box-Cox transformation)




### ARIMA model 

```{r}
# Load the forecast package
library(forecast)

# Function to fit and forecast ARIMA model
fit_and_forecast_arima <- function(ts_data, country) {
  # Fit the ARIMA model
  arima_model <- auto.arima(ts_data, seasonal = FALSE)
  
  # Generate a forecast
  arima_forecast <- forecast(arima_model, h = 12) # Forecast 12 months ahead
  
  # Plot the forecast
  plot(arima_forecast, main = paste("ARIMA Forecast for", country))
}

# Apply the function to your time series data for each country
fit_and_forecast_arima(ts_germany, "Germany")
fit_and_forecast_arima(ts_france, "France")
fit_and_forecast_arima(ts_italy, "Italy")
fit_and_forecast_arima(ts_austria, "Austria")
fit_and_forecast_arima(ts_liechtenstein, "Liechten")
fit_and_forecast_arima(ts_data, "Total.Export")
```
### SARIMA (ARIMA with seasonality)

```{r}
# Load the forecast package
library(forecast)

# Function to fit and forecast ARIMA model
fit_and_forecast_sarima <- function(ts_data, country) {
  # Fit the ARIMA model
  sarima_model <- auto.arima(ts_data, seasonal = TRUE)
  
  # Generate a forecast
  sarima_forecast <- forecast(sarima_model, h = 12) # Forecast 12 months ahead
  
  # Plot the forecast
  plot(sarima_forecast, main = paste("SARIMA Forecast for", country))
}

# Apply the function to your time series data for each country
fit_and_forecast_sarima(ts_germany, "Germany")
fit_and_forecast_sarima(ts_france, "France")
fit_and_forecast_sarima(ts_italy, "Italy")
fit_and_forecast_sarima(ts_austria, "Austria")
fit_and_forecast_sarima(ts_liechtenstein, "Liechten")
fit_and_forecast_sarima(ts_data, "Total.Export")
```
### Accuracy tests for our forecasts
```{r}
# Load the forecast package
library(forecast)

# Split the data into a training and a test set
train_data <- window(ts_germany, end = c(2019, 12))
test_data <- window(ts_germany, start = c(2020, 1))

# Fit the SARIMA model
sarima_model <- auto.arima(train_data, seasonal = TRUE)

# Fit the ETS model
ets_model <- ets(train_data, model = "ANA")

# Fir the ARIMA model
arima_model <- auto.arima(train_data, seasonal = FALSE)

# Generate forecasts for both models
sarima_forecast <- forecast(sarima_model, h = length(test_data))
ets_forecast <- forecast(ets_model, h = length(test_data))
arima_forecast <- forecast(arima_model, h = length(test_data))


# Calculate accuracy metrics for both models
accuracy_sarima <- forecast::accuracy(sarima_forecast, test_data)
accuracy_ets <- forecast::accuracy(ets_forecast, test_data)
accuracy_arima <- forecast::accuracy(arima_forecast, test_data)

# Compare accuracy metrics
print("SARIMA model accuracy:")
print(accuracy_sarima)
print("ETS model accuracy:")
print(accuracy_ets)
print("ARIMA model accuracy:")
print(accuracy_arima)
```
J'ai créé une fonction pour essayer de le calculer pour tout les pays : 


```{r}

library(forecast)

compare_models <- function(ts_data) {
  # Train-test split
  train_data <- window(ts_data, end = c(2019, 12))
  test_data <- window(ts_data, start = c(2020, 1))
  
  # ETS models
  ets_zzz <- ets(train_data, model = "ZZZ")
  ets_ana <- ets(train_data, model = "ANA")
  
  if (all(train_data > 0)) {
    ets_mnm <- ets(train_data, model = "MNM")
    ets_mnm_forecast <- forecast(ets_mnm, h=length(test_data))
    accuracy_ets_mnm <- forecast::accuracy(ets_mnm_forecast, test_data)
  }
  
  ets_aaa <- ets(train_data, model = "AAA")
  
  ets_zzz_forecast <- forecast(ets_zzz, h=length(test_data))
  ets_ana_forecast <- forecast(ets_ana, h=length(test_data))
  ets_aaa_forecast <- forecast(ets_aaa, h=length(test_data))
  
  # ARIMA model
  arima_model <- auto.arima(train_data, seasonal = FALSE)
  arima_forecast <- forecast(arima_model, h=length(test_data))
  
  # SARIMA model
  sarima_model <- auto.arima(train_data, seasonal=TRUE)
  sarima_forecast <- forecast(sarima_model, h=length(test_data))
  
  # Calculate accuracy
  accuracy_ets_zzz <- forecast::accuracy(ets_zzz_forecast, test_data)
  accuracy_ets_ana <- forecast::accuracy(ets_ana_forecast, test_data)
  accuracy_ets_aaa <- forecast::accuracy(ets_aaa_forecast, test_data)
  accuracy_arima <- forecast::accuracy(arima_forecast, test_data)
  accuracy_sarima <- forecast::accuracy(sarima_forecast, test_data)
  
  # Combine accuracy results
  accuracy_results <- list(
    ETS_ZZZ=accuracy_ets_zzz,
    ETS_ANA=accuracy_ets_ana,
    ETS_AAA=accuracy_ets_aaa,
    ARIMA=accuracy_arima,
    SARIMA=accuracy_sarima
  )
  
  if (exists("accuracy_ets_mnm")) {
    accuracy_results$ETS_MNM <- accuracy_ets_mnm
  }
  
  return(accuracy_results)
}


# Example usage
compare_models(ts_germany)

```
For Italy : 

```{r}
compare_models(ts_italy)
```

For Austria : 

```{r}
compare_models(ts_austria)
```

For France : 

```{r}
compare_models(ts_france)
```

For Liechtenstein : 

```{r}
compare_models(ts_liechtenstein)
```

For overall data  : 

```{r}
compare_models(ts_data)
```
```{r}
library(fable)
# List of country tsibbles
country_tsibbles <- list(
  Germany = ts_germany_tsibble,
  Italy = ts_italy_tsibble,
  Austria = ts_austria_tsibble,
  France = ts_france_tsibble,
  Liechtenstein = ts_liechtenstein_tsibble
)

# Function to create ensemble forecasts for each country
ensemble_forecasts <- function(ts_country_tsibble) {
  
  # Check if any value is non-positive and replace it with a small positive value
  if (any(ts_country_tsibble$value <= 0)) {
    ts_country_tsibble$value <- pmax(ts_country_tsibble$value, 1e-9)
  }
  
  # Create STLF model using STL decomposition and ETS for seasonally adjusted data
  STLF <- decomposition_model(
    STL(log(value) ~ season(window = Inf)),
    ETS(season_adjust ~ season("N"))
  )
  
  # Fit the models and create ensemble using dplyr and fable
  country_models <- ts_country_tsibble %>%
    model(
      ets = ETS(value),
      stlf = STLF,
      arima = ARIMA(log(value))
    ) %>%
    mutate(combination = (ets + stlf + arima) / 3) %>%
    # Handle any errors during the model fitting process
    tryCatch(
      error = function(e) {
        warning("Error encountered during model fitting: ", conditionMessage(e))
        return(NULL)
      }
    )
  
  if (is.null(country_models)) {
    return(NULL)
  }
  
  # Forecast for 5 years (60 months)
  country_forecast <- country_models %>%
    forecast(h = 60) %>%
    # Handle any errors during the forecasting process
    tryCatch(
      error = function(e) {
        warning("Error encountered during forecasting: ", conditionMessage(e))
        return(NULL)
      }
    )
  
  return(country_forecast)
}

# Apply the function to all country tsibbles
forecast_results <- lapply(country_tsibbles, ensemble_forecasts)

# Example usage: Access forecasts for Germany
forecast_results$Germany
```